CRYPTOCOMMS IS INTENDED SOLELY AS A DEMONSTRATION OF THE AUTHOR'S SKILLS AND SHOULD NOT BE
USED TO SECURE REAL COMMUNICATIONS. SEE THE FILE WARNING_README FOR THE FULL WARNING.

This file documents the cryptographic design used by Cryptocomms for secure communication.
The document describes the cryptographic design as though it were a design intended for
practical use, BUT IT IS NOT.

This cryptographic design was invented by the author as a demonstration of their ability
to work with cryptographic concepts. The design has not been subject to any kind of proper
cryptographic analysis by experts in cryptography. Moreover, the design is intentionally
very simple, and thus lacks some features which are needed for good-quality cryptographic
security (such as forward security via the use of ephemeral secrets). Therefore, THE
CRYPTOGRAPHIC DESIGN DESCRIBED HERE SHOULD NOT BE USED TO SECURE REAL COMMUNICATIONS AND
IS PURELY AN ACADEMIC EXERCISE DESIGNED TO SHOWCASE THE AUTHOR'S SKILLS.

In this document, the word "byte" means an octet of bits.


################
# 1 - Overview #
################

Cryptocomms uses a very simple protocol to exchange packets of encrypted data between
hosts. This document describes the protocol's design. For ease of reference, we shall in
this document call the cryptographic protocol "Cryptoprot".

In very general terms, Cryptoprot accepts a sequence of byte strings. It encrypts each
byte string using the AES-256 GCM Authenticated Encryption with Additional Data (AEAD)
system, and then encapsulates this encrypted data by prepending a 24-byte header and
appending the 16-byte AEAD tag generated by the encryption. It then hands off the packet
for delivery to the remote peer by some transport layer system.

The design of Cryptoprot does not concern itself with the content of the byte strings to
be delivered, nor with any details of how they will be delivered to the remote host. In
the Cryptocomms application, the byte strings handed into Cryptoprot contain a combination
of user data and metadata used by Cryptocomms to achieve reliable delivery, and the
packets produced by Cryptoprot are handed to the device's UDP subsystem for transmission
to the remote peer as the data payload in a UDP packet. This context is not, however,
directly relevant for the design of Cryptoprot beyond ensuring that the protocol should
function efficiently when used in this way.

Cryptoprot does not use any public key cryptography, but rather relies completely for its
security on a static 32-byte secret value shared by the two hosts. In particular,
Cryptoprot does not use any ephemeral secrets and thus has absolutely no forward security,
meaning that an attacker who learns the shared secret value can decrypt all past and
future communications which they have intercepted or will later intercept, and can also
impersonate either peer to the other.

One of the design goals of Cryptoprot is speed, and so the design allows for an
implementation which makes no use of non-volatile storage during normal operation, but
rather holds its runtime state totally in volatile memory (which invariably means some
kind of RAM). The only data which Cryptoprot needs to be stored in non-volatile memory is
its configuration (which is generally static and which Cryptoprot reads but never writes)
and an integral value used to ensure that unique initialization vectors are used for each
AEAD encryption. This latter value needs to be read and written each time Cryptoprot is
initialized, and very infrequently if at all during normal operation.


##########################
# 2 - Hosts and channels #
##########################

A Cryptoprot "session" is a period of communication between two hosts during which both
hosts are able to maintain their internal state. In practical terms, this means a period
during which Cryptocomms processes are running continuously on both hosts.

Cryptoprot hosts are identified by a 4-byte "host id", which must be unique amongst all of
the hosts within one intercommunicating network of hosts. Any 4-byte value is a valid host
id, and thus a network of Cryptoprot hosts can have at most 2^32 = 4,294,967,296 hosts.

Cryptoprot allows for multiple independent "channels" of communication between two hosts.
Channels are identified by a 2-byte "channel id", which must be unique amongst all
channels between the same two hosts. Note that channels are bidirectional and the two ends
of the channel have exactly the same status. Any 2-byte value is a valid channel id, and
thus any two hosts may have at most 2^16 = 65,536 channels between them.

A pair of communicating Cryptoprot hosts share a 32-byte shared secret, which we shall
call the the "base secret" of the host pair. For the best level of security, every pair of
hosts should have a different base secret, so that each Cryptoprot host stores one secret
for each peer it communicates with. It is possible for all host pairs within a
communicating network of Cryptoprot hosts to use the same base secret for ease of
configuration, but in this case the compromise of a single host compromises all security
of the whole network. From the "base secret", a Cryptocomms host derives a separate pair
of symmetric encryption keys (one to send, one to receive) for each channel it shares with
the peer.

The base secret of a host pair is the single source of cryptographic randomness in their
communications, and thus this secret must be generated in a secure environment from a
cryptographic-quality random number generator, and its secrecy must be protected. Due to
the lack of forward-security in the design of Cryptoprot, the base secret must be securely
deleted from both hosts when it is no longer needed.

A Cryptoprot host maintains a separate state for each channel it has with each peer. We
shall henceforth use the term "connection" to denote a particular Cryptoprot channel
between two particular hosts, together with all of the state which a host holds for this
channel. Since all communication happens within some connection, and the connections
function independently of each other, it follows that describing the functioning of a
single connection will suffice to explain Cryptoprot.


######################################
# 3 - Scenario and basic definitions #
######################################

In the following sections, we shall describe in detail the functioning of a Cryptoprot
connection.  We shall now establish some definitions and notation which we shall use
in the descriptions below.

We shall consider a Cryptoprot connection between two hosts, which we shall call host A
and host B. We shall call A's 4-byte host id "id-A", and similarly "id-B" for B's id. The
2-byte channel id of the connection we shall call "id-channel". We shall call A and B's
shared 32-byte base secret "base-secret".


##########################
# 4 - Cryptographic keys #
##########################

In this section, we describe the cryptographic keys used in a Cryptoprot connection.

Each host derives two 32-byte keys from base-secret, one for sending and one for
receiving, with each host's sending key being the other's receiving key. The keys are
derived using the HKDF expand operation as defined in section 2.3 of IETF RFC 5869, which
we represent as HKDF-Expand(PRK,INFO,L), where PRK is the pseudorandom key, INFO is the
context parameter, L is the output byte length, and the hash function used to instantiate
the HKDF operation is SHA-256.

A derives its keys, which we shall call A-send-key and A-recv-key, from base-secret and
the two 10-byte strings A-send-info and A-recv-info, derived as follows

A-send-info := id-A|id-B|id-channel
A-recv-info := id-B|id-A|id-channel

where "|" denotes concatenation. The 32-byte keys are then derived as follows

A-send-key := HKDF-Expand(base-secret, A-send-info, 32)
A-recv-key := HKDF-Expand(base-secret, A-recv-info, 32)

B derives its keys symmetrically. We see that B-send-key=A-recv-key and B-recv-key=A-send-key.


###########################################
# 5 - Segment numbers and message numbers #
###########################################

A Cryptoprot connection uses two numbers to give each packet it sends a unique identity, a
"segment number" and a "message number". Both of these are 6-byte unsigned integers. This
section gives an overview of their use, with full details in later sections.

A Cryptoprot connection generates a new segment number at the start of each session. It is
vital for the security of the connection that any segment number which is generated for
use by a connection must never have been used before for communication in a previous
instance of that connection with the same base secret. Cryptocomms ensures this by
generating segment numbers based on the number of milliseconds since the UNIX epoch, but
augmented with the use of non-volatile storage to ensure that generated segment numbers
increase monotonically across all instances of a connection. This use of the system clock
and non-volatile storage together means that both must fail (or be tampered with) at the
same time to cause a re-use of a segment number.

The connection then uses its segment number alongside a message number which is
incremented for each message sent, ensuring that every message sent by this host on this
connection has a unique combination of segment number and message number. The segment
number and message number are written into the header of each message sent by the
connection.

The message's segment number and message number are combined to form the initialization
vector for the authenticated encryption of the message's contents, ensuring that each
message encrypted with the connection's sending key (see below) has a unique
initialization vector.

If the connection's message number reaches the maximum value which can fit in a 6-byte
unsigned integer, the connection generates a new segment number and resets the message
number counter.

Note that the segment number 0 is reserved for a special use in establishing
communications and may thus not be used as a normal segment number.

The use of this system of a segment number with a strict uniqueness requirement which does
not change frequently, together with a constantly-changing message number which can be
implemented via a simple counter in volatile memory allows for both security and speed.


######################################
# 6 - Packet format and cryptography #
######################################

Cryptoprot uses the same format for all of the packets it produces. The packet is split
into three sections: the Cryptoprot header, the encrypted data, and the AEAD tag. The
Cryptoprot header has a fixed length of 24 bytes, the encrypted data can consist of any
number of bytes (including a length of zero bytes), and the AEAD tag has a fixed length of
16 bytes. The Cryptoprot header is made up of five fields.

The overall structure of a packet is shown in the following diagram. The numbers in square
brackets give the length of each field in bytes.

-------------------------------------------------------------------------------------------
| sender id [4] | channel id [2] | receiver segment number [6] | sender segment number [6] |
-------------------------------------------------------------------------------------------
  message number [6] | encrypted data [0+] | AEAD tag [16] |
 -----------------------------------------------------------

The five fields before the encrypted data together constitute the Cryptoprot header, and
together have a length of 24 bytes.

The three header fields whose name ends with "number" hold 6-byte unsigned integers. These
integers are written to the header fields in little-endian byte order (i.e. least
significant byte first).

Note that the packet contains no information concerning the delivery of the packet to the
peer host. It is the responsibility of the rest of the Cryptocomms application to send and
receive packets between hosts.

The use of encryption in this packet format is as follows. We shall write
(CT, TAG) := ENC(K, IV, AD, PT)
to mean that CT and TAG are the ciphertext and AEAD tag (respectively) obtained by
applying AES-256 GCM authenticated encryption to the plaintext PT, with secret key K,
initialization vector IV, and additional data AD. Thus CT is a byte string of the same
length as PT, and TAG is a 16 byte value. For a packet as above, let
  RSN be the 6-byte receiver segment number field from the packet
  SSN be the 6-byte sender segment number field from the packet
  MSN be the 6-byte message number field from the packet
  ED be the encrypted data field from the packet (the length of ED may be 0 bytes)
  TAG be the 16-byte AEAD tag from the packet
  DATA be the unencrypted payload data used to create the packet
  K be the 32-byte sending key of the host which created the packet
Then we have
(ED,TAG) := ENC(K, SSN|MSN, RSN, DATA)

where "|" denotes concatenation. Note that the IV value in this ENC is 12 bytes long. Note
that the sender id and channel id fields of the packet are not used in the above
encryption. These two fields are only present to allow the packet to be delivered to the
correct connection at the receiving host. It is not necessary to include them in the
additional data field because the peer host id and channel id have already been used in
deriving the sending and receiving keys.


########################
# 7 - Connection state #
########################

In this section, we describe the values which constitute the state of a Cryptoprot
connection. We shall describe the state of the host A, as host B's state is completely
symmetrical.

The values id-A, id-B, id-channel, A-send-key=B-recv-key, and B-send-key=A-recv-key have
been defined above. These values remain static throughout the session.

The part of the state of the connection which changes during operation consists of these
items:
  >> A's current segment number, a 6-byte unsigned integer which we shall call
     "self-segnum"
  >> A's previous segment number, a 6-byte unsigned integer which we shall call
     "old-self-segnum"
  >> A's message number counter, a 6-byte unsigned integer which we shall call
     "msgnum"
  >> B's current segment number, a 6-byte unsigned integer which we shall call
     "peer-segnum"
  >> B's previous segment number, a 6-byte unsigned integer which we shall call
     "old-peer-segnum"
  >> some structure for recording which message numbers have been received from the
     peer with the sender segment number in peer-segnum, which we shall call
     "msgnum-tracker"
  >> some structure for recording which message numbers have been received from the
     peer with the sender segment number in old-peer-segnum, which we shall call
     "old-msgnum-tracker"

When the connection is initialized, a new segment number is generated and stored in
self-segnum, msgnum is set to some small initial value (such as 0 or 1), peer-segnum,
old-peer-segnum, and old-self-segnum are set to 0, and msgnum-tracker and
old-msgnum-tracker are initialized to a state where they do not have any message numbers
recorded as received.

The values in the above list whose names begin with "old-" are not strictly necessary for
the design of Cryptoprot to work, but are included as an optimisation to allow packets sent
using previous segment numbers to be accepted rather than rejected (which results in the
loss of the data contained in those packets). In practice, these optimisations are perhaps
not of great utility, as the changing of segment numbers is a very rare event which may
not happen at all in most exchanges.


########################################
# 8 - Sending and receiving of packets #
########################################

Before A and B can exchange packets containing a non-empty data payload, they must learn
each others' current segment numbers. How this is done is described in the section
"Segment number discovery" below.

## Packet sending ##

Suppose that a Cryptoprot connection on A is handed the byte string DATA to be sent to the
corresponding connection on B.

Firstly, A checks if peer-segnum is 0. If so, A must first discover B's connection's
current segment number. How this is done is described in a later section, so we shall
assume that peer-segnum contains B's current segment number.

A checks that the sending message number counter, msgnum, is less than 2^48 =
281,474,976,710,656. If not, the value in self-segnum is moved to old-self-segnum (whose
previous value is discarded), a new segment number is generated and stored in self-segnum,
and msgnum is reset to a small initial value such as 0 or 1.

A forms a message header by assigning the values of the header fields as follows. The
unsigned integers peer-segnum, self-segnum, and msgnum are encoded as 6-byte little-endian
values

  sender id <- id-A
  channel id <- id-channel
  receiver segment number <- peer-segnum
  sender segment number <- self-segnum
  message number <- msgnum

Then A computes the "encrypted data" and "AEAD tag" packet fields as given in the section
"Packet format and cryptography", concatenates the header, encrypted data, and tag, and
passes the resulting packet off for delivery to B.

The packet thus produced by A is length(DATA)+40 bytes long (40 = 24+16, with 24 bytes for
the header and 16 bytes for the tag). Note that is is the responsibility of the system
which hands DATA to A for sending to ensure that a byte string of length length(DATA)+40
bytes can be delivered to B by whatever mechanism is used for this purpose, and to limit
the length of DATA accordingly.


## Packet receiving ##

Upon receiving a packet of data, a Cryptoprot host examines the first 6 bytes of the
message to see if they contain the concatenation of a known peer id and a known channel id
used with that peer. If so, the packet is passed to the appropriate connection. If not, it
is discarded. Note that the first 6 bytes of the packet are not used again after this
point.

On receiving a packet, a connection reads the values out of the header as described above,
and does as follows. Note that any packet whose length is less than 40 bytes cannot be
valid, and so such packets should be discarded without proceeding further.

  1 - Check that the receiver segment number is equal to either self-segnum or
  old-self-segnum. If not, the packet will be discarded, but an empty response packet may
  need to be sent to inform the peer of self-segnum, see the section "Segment number
  discovery" below.

  2 - If the sender segment number is equal to peer-segnum or old-peer-segnum, query
  msgnum-tracker or old-msgnum-tracker as appropriate to see if the message number has
  already been logged (see step 5, below). If it has, discard the packet. Note that the
  sender segment number in the packet will never be 0 if it has arrived uncorrupted from
  the real peer, and any packet which violates this should be discarded (we note this
  because old-peer-segnum will often be equal to 0 to indicate that there is no previously
  used segment number).

  3 - If the sender segment number is not equal to peer-segnum or old-peer-segnum, discard
  the packet if the sender segment number is not greater than peer-segnum.

  4 - Attempt to decrypt and authenticate the packet contents according to the
  cryptographic formula in "Packet format and cryptography". If the authentication fails,
  discard the packet. Otherwise, we obtain the unencrypted packet plaintext. Pass this
  plaintext on to the rest of the Cryptocomms application.

  5 - If the sender segment number in the packet was peer-segnum or old-peer-segnum, log
  the message number as received with either msgnum-tracker or old-msgnum-tracker, as
  appropriate. If this is not the case, then move peer-segnum and msgnum-tracker to
  old-peer-segnum and old-msgnum-tracker (discarding their previous values), set
  peer-segnum to the sender segment number from the packet, re-initialize msgnum-tracker
  to a state where no message numbers are recorded as received, and log the message number
  from the packet.


################################
# 9 - Segment number discovery #
################################

Before a Cryptoprot connection can send its peer a packet containing a data payload, it
must first learn its peer's current segment number to put in the receiver segment number
field of the packet header, and to use as the additional data of the authenticated
encryption. Looking at the steps for receiving a packet set out above, we see that the
data contained in a packet will not be accepted unless the packet's receiver segment
number field contains the receiver's current or previous segment number from this
session. The reason for this design feature is to tie all valid packets to the receiver's
current session, preventing replay attacks using packets from previous sessions.

To allow for segment number discovery, two additional actions must be added to the sending
and receiving processes set out in "Sending and receiving of packet".

1 - An additional sub-step must happen in step 1 of the receiving process laid out in the
section "Sending and receiving of packets", as follows. If A receives a packet with a
receiver segment number which is not equal to the connection's self-segnum or
old-self-segnum, then its contents (which may be empty) are decrypted. If the
authenticated decryption fails, the packet is discarded without response. If it succeeds,
then any data payload is discarded, but an empty packet is sent using the process set out
in "Sending and receiving of packets" BUT with receiver segment number set to the sender
segment number from the received packet. When this packet is received by B, it will (via
the receiving process described in "Sending and receiving of packets") cause B to record
A's new segment number and begin using it for sending.

2 - When A is passed data to send to B, it first checks if peer-segnum is 0. If so, A must
discover B's current segment number (the value 0 for a segment number is a special value
reserved to mean "unknown" or "not in use"). A does this by sending a packet with the
format as given above, with an empty data payload and the receiver segment number set to
0, which we call a "hello packet". The sending of the hello packet can be repeated after a
suitable interval if no response is received. When B receives the hello packet, it will
trigger the process set out in the previous point, causing B to send a response containing
its current segment number.