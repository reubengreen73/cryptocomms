=== Overview ===
Cryptocomms will be a simple system for encrypted communication written in C++.

The purpose of this project is for me to demonstrate my skills in software development,
and in C++ in particular. It is NOT intended for actual use, as I am not an expert in
cryptography or secure coding.


== Build system ===
Cryptocomms uses a very simple custom build system.

The build system is a python script, gen_makefile.py, which examines the project
files and generates a Makefile. This Makefile can then be used to compile the project.
More specifically, the gen_makefile.py script scans each .cpp for #include lines with
double quotes, and then deduces dependencies accordingly.

Conceptually, the cryptocomms source code consists of the file main.cpp and a number of
"units", each unit being composed of a .cpp file and a .h file with matching base file
names. These source files live in the top-level project directory.

The tests for the project are put in files with the .tests.cpp suffix in the "tests"
directory. These files are examined by the gen_tester.py script, and all the tests are
incorporated into the test runner binary which it generates. See below for details.

The gen_makefile.py script needs to be re-run when a new .cpp file is added (including a
.tests.cpp file in tests), or an existing .cpp file's double-quote #include statements
change.


== Test framework ===
Cryptocomms uses a very simple custom test framework.

The main component of the test framework is a python script, gen_tester.py, which generates
C++ source code for a test runner binary which will run some or all of the project's tests.
The tests should be placed in files with the extension .tests.cpp in the directory "tests".

Each .tests.cpp file should #include the header file testsys.h, which defines three macros
TESTFUNC, TESTASSERT, and TESTTHROW. Test functions then have the following form:

  TESTFUNC(func_name){

    /* test code */

    int result;
    /* test code */
    TESTASSERT(result == 1);

    /* the following checks that some_func(bad_arg) throw an exception
     * whose what() string contains "func error"
     */
    TESTTHROW(some_func(bad_arg),"func error");

  }

The gen_tester.py script is called automatically from the Makefile if any .test.cpp file changes,
so it should never be necessary to call it manually.

The TESTFUNC macro used to declare a test function serves two purposes. Firstly, it declares a
function of the correct type with a fixed string prepended to the supplied name. Secondly, it
marks the function for inclusion in the collection of functions called by the "tester" binary.
Note that the TESTFUNC declaration must be made at global scope, and that the name passed to
TESTFUNC must be unique amongst all tests across all files.

The test runner binary is called "tester" and is generated by running "make tester" or indirectly
by running "make all". Invoking the binary with no arguments runs all tests, while invoking it with
a list of base names of .test.cpp files will invoke only the tests in those files. For example,
"./tester Foo Bar" will run only the tests from tests/Foo.tests.cpp and tests/Bar.tests.cpp.

All identifiers (including macro names) beginning with "testsys_" or "TESTSYS_" are reserved for
the internal use of the test system. More specifically, any file which #includes tests/testsys.h
should not use these identifiers at global scope, or in any test function defined with TESTFUNC.
In practice, the files which #include test are the *tests.cpp files in the "tests" directory.