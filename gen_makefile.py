#!/usr/bin/env python3

# This script generates the project makefile. It automatically discovers
# dependencies by scanning the project's .cpp files. It takes no arguments.

import os, re, sys
from string import Template

TESTS_DIR = "tests"  # defines where source code for tests is kept

# extract_quote_includes extracts all double-quote includes from the file
# at the given path, and returns a list of paths to these files from the
# current directory
def extract_quote_includes(path):
    with open(path,'r') as fh:
        includes =  re.findall(r'^#include\s+"(\S+)"',fh.read(),flags=re.MULTILINE)
    head,_ = os.path.split(path)
    return [os.path.relpath(os.path.join(head,x)) for x in includes]

# get_full_includes extracts all double-quote includes from the file at the
# given path, and from the corresponding header file if it exists. It returns
# a list of paths to these files from the current directory.
def get_full_includes(path):
    basepath,_ = os.path.splitext(path)
    h_files = extract_quote_includes(path)
    unit_h_file = basepath+'.h'
    if(os.path.isfile(unit_h_file)):
        h_files += extract_quote_includes(unit_h_file)
        h_files = list(set(h_files))
    return h_files

if(not os.path.isdir(TESTS_DIR)):
    print(f"Error: directory \"{TESTS_DIR}\" does not exist")
    quit()

# create a list of all "unit" and "test" cpp files
# "unit" cpp files are files ending ".cpp" in the main source directory, except main.cpp and tester.cpp
# "test" cpp files are files ending ".tests.cpp" in the TESTS_DIR directory
unit_cpp_files = [x for x in os.listdir('.') if x.endswith('.cpp')]
unit_cpp_files = [x for x in unit_cpp_files if not x in ['main.cpp','tester.cpp']]
test_cpp_files = [os.path.join(TESTS_DIR,x) for x in os.listdir(TESTS_DIR) if x.endswith('.tests.cpp')]

# This is the main template for generating the makefile.
# There are 6 placeholders:
#     ALL_TEST_CPP_FILES is a space-separated list of all .test.cpp files found in TESTS_DIR
#     ALL_UNIT_O_FILES is a space-separated list of all generated non-test object files
#     ALL_TEST_O_FILES is a space-separated list of all generated test object files
#     MAIN_H_FILES is a space-separated list of all headers included via double-quote in main.cpp
#     UNIT_O_FILE_RULES is a chunk consisting of rules to generate each object file mentioned in ALL_UNIT_O_FILES
#     TEST_O_FILE_RULES is a chunk consisting of rules to generate each object file mentioned in ALL_TEST_O_FILES
makefile_template_string = """\
# THIS FILE IS AUTOMATICALLY GENERATED, DO NOT MODIFY IT MANUALLY
# To regenerate this file, run """ + sys.argv[0] + """


DBG := -g
CHECKS := -Wall -Wpedantic


all: cryptocomms tester

clean:
	rm *.o cryptocomms tester tester.cpp


## Rules for the cryptocomms executable and the tester ##

cryptocomms: main.o $ALL_UNIT_O_FILES
	g++ $$(DBG) -pthread main.o $ALL_UNIT_O_FILES -lcrypto -o cryptocomms

tester: tester.o testsys.o $ALL_UNIT_O_FILES $ALL_TEST_O_FILES
	g++ $$(DBG) -pthread tester.o testsys.o $ALL_UNIT_O_FILES $ALL_TEST_O_FILES -lcrypto -o tester

main.o: main.cpp $MAIN_H_FILES
	g++ $$(DBG) -std=c++14 $$(CHECKS) -c main.cpp

tester.o: tester.cpp
	g++ $$(DBG) -std=c++14 $$(CHECKS) -c tester.cpp

testsys.o: tests/testsys.cpp
	g++ $$(DBG) -std=c++14 $$(CHECKS) -c tests/testsys.cpp

tester.cpp: $ALL_TEST_CPP_FILES
	./gen_tester.py


## Rules for compiling unit object files ##

$UNIT_O_FILE_RULES


## Rules for compiling test object files ##

$TEST_O_FILE_RULES
"""
makefile_template = Template(makefile_template_string)

# generate the values of some placeholders in makefile_template
all_test_cpp_files = ' '.join(test_cpp_files)
all_unit_o_files = ' '.join([x[:-4]+'.o' for x in unit_cpp_files])
all_test_o_files = ' '.join([os.path.basename(x[:-4]+'.o') for x in test_cpp_files])
main_h_files = ' '.join(extract_quote_includes('main.cpp'))

# This is the template to generate a rule for compiling a .cpp file
# There are three placeholders:
#     BASENAME is the main part of the filename of the .cpp file, without any path,
#         and without the ".cpp" extension
#     H_FILES is a space-separated list of all the headers included in the .cpp file
#         via a double-quote #include
#     FILEPATH is the full path to the file relative to the main source directory
rule_template_string = """\
${BASENAME}.o: ${FILEPATH} $H_FILES
	g++ $$(DBG) -std=c++14 $$(CHECKS) -c ${FILEPATH}"""
rule_template = Template(rule_template_string)

# generate the rules to compile all the non-test .cpp files, for the UNIT_O_FILE_RULES
# placeholder of makefile_template
unit_o_file_rules_chunks = []
for filename in unit_cpp_files:
    h_files = ' '.join(get_full_includes(filename))
    basename,_ = os.path.splitext(filename)
    unit_o_file_rules_chunks.append(rule_template.substitute(BASENAME=basename,
                                                             FILEPATH=filename,
                                                             H_FILES=h_files))
unit_o_file_rules = '\n\n'.join(unit_o_file_rules_chunks)

# generate the rules to compile all the test .cpp files, for the TEST_O_FILE_RULES
# placeholder of makefile_template
test_o_file_rules_chunks = []
for filepath in test_cpp_files:
    h_files = ' '.join(get_full_includes(filepath))
    basename,_ = os.path.splitext(os.path.basename(filepath))
    test_o_file_rules_chunks.append(rule_template.substitute(BASENAME=basename,
                                                             FILEPATH=filepath,
                                                             H_FILES=h_files))
test_o_file_rules = '\n\n'.join(test_o_file_rules_chunks)

# create the makefile text and write it to file
makefile_text = makefile_template.substitute(ALL_TEST_CPP_FILES=all_test_cpp_files,
                                             ALL_UNIT_O_FILES=all_unit_o_files,
                                             ALL_TEST_O_FILES=all_test_o_files,
                                             MAIN_H_FILES=main_h_files,
                                             UNIT_O_FILE_RULES=unit_o_file_rules,
                                             TEST_O_FILE_RULES=test_o_file_rules)
fh = open('Makefile','w')
fh.write(makefile_text)
fh.close()
