#!/usr/bin/env python3

# This script generates the source file for the test runner binary from all of the
# *.tests.cpp files in TESTS_DIR. It takes no arguments.
#

import os, re, sys
from string import Template

TESTS_DIR = "tests"         # sets which directory to search for .tests.cpp files
TEST_SOURCE = "tester.cpp"  # sets the name of the output cpp file

# This is the main template used to generate the test runner binary source file.
# There are 2 placeholders:
#     RUNTESTS_FUNCTIONS is replaced by a text chunk containing one text block per
#       XXX.tests.cpp file, which consists of declarations of all the individual functions
#       and a single XXX_runtests function to run them all (the XXX_runtests function
#       is generated from the template runtests_function_template, below)
#     ADD_RUNTESTS_FUNCTIONS is a chunk consisting of lines which add all the XXX_runtests
#       to the std::map runtests_funcs
test_source_template_string = """\
/* THIS FILE IS AUTOMATICALLY GENERATED, DO NOT MODIFY IT MANUALLY
 * To regenerate this file, run """ + sys.argv[0] + """
 */

#include <string>
#include <stdexcept>
#include <iostream>
#include <map>

typedef void (*testsys_function_t)();

bool run_test(testsys_function_t test_function)
{
  try{
    test_function();
  }
  catch(std::exception& ex){
    std::cout << "  [!] " << ex.what() << std::endl;
    return false;
  }
  return true;
}

$RUNTESTS_FUNCTIONS

int main(int argc, char** argv){
  std::map<std::string,int(*)()> runtests_funcs;
  int failed_tests_count = 0;

$ADD_RUNTESTS_FUNCTIONS

  for(int i=1;i<argc;i++){
    auto section_name = std::string(argv[i]);
    try{
      failed_tests_count += (runtests_funcs.at(section_name))();
    }
    catch(std::out_of_range& oor){
      std::cout << std::string("ERROR: Unknown test section \\"") << section_name
        << std::string("\\"") << std::endl;
    }
  }

  if(argc == 1){
    for(auto& x: runtests_funcs){
      failed_tests_count += (x.second)();
    }
  }

  if(failed_tests_count == 0){
    std::cout << std::endl << "ALL TESTS PASSED" << std::endl;
  } else {
    std::string msg = (failed_tests_count == 1) ? " TEST FAILED" : " TESTS FAILED";
    std::cout << std::endl << failed_tests_count << msg << std::endl;
  }

  return 0;
}
"""
test_source_template = Template(test_source_template_string)


# Scan all of the .tests.cpp files in TESTS_DIR for uses of the TESTFUNC macro,
# which marks a test function.

if not os.path.isdir(TESTS_DIR):
    print(f"Error: directory \"{TESTS_DIR}\" does not exist");
    quit();

test_dir_listing = os.listdir(TESTS_DIR)
files_to_scan = [x for x in test_dir_listing if x.endswith(".tests.cpp")]
sections = {}
for filename in files_to_scan:
    section_name,_ = filename.split(".tests.cpp")
    filepath = os.path.join(TESTS_DIR,filename)

    fh = open(filepath,'r')
    text = fh.read()
    fh.close()

    testfuncs = re.findall(r'TESTFUNC\((.*)\)',text)
    sections[section_name] = testfuncs


# All of the test functions for each XXX.tests.cpp file are invoked in a
# function called XXX_runtests(), which is made using the following template.
# There are 3 placeholders
#   TESTFUNC_DECLS is a sequence of lines declaring the test functions
#   SECTION is the part of the source file name before the .tests.cpp
#   RUN_TEST_INVOCATIONS is a sequence of lines, each calling the function
#     run_test() to run one of the test functions
runtests_function_template_string = """$TESTFUNC_DECLS
int ${SECTION}_runtests(){
  int failed_test_count = 0;

  std::cout << "Running tests for ${SECTION}" << std::endl;

$RUN_TEST_INVOCATIONS

  return failed_test_count;
}"""
runtests_function_template = Template(runtests_function_template_string)

# Template to generate calls to run_test for each test function, and to
# increment the count of failed tests if the test fails. There is one
# placeholder, FN, which is the name of the test function as passed to
# the TESTFUNC macro.
run_test_call_template_string = """\
  if(not run_test(testsys_function_${FN}))
    failed_test_count++;
"""
run_test_call_template = Template(run_test_call_template_string)

# Generate the value of the RUNTESTS_FUNCTIONS placeholder of test_source_template,
# consisting of one *_runtests() function for each .tests.cpp file and the associated
# declarations of the test functions
runtests_function_subchunks = []
for section in sections:
    testfunc_decl_lines = [f"void testsys_function_{fn}();" for fn in sections[section]]
    testfunc_decls_chunk = '\n'.join(testfunc_decl_lines)
    run_test_invocations_blocks = [run_test_call_template.substitute(FN=fn) for fn in sections[section]]
    run_test_invocations_chunk = '\n'.join(run_test_invocations_blocks)
    runtests_function_chunk = runtests_function_template.substitute(TESTFUNC_DECLS=testfunc_decls_chunk,
                                                                    SECTION=section,
                                                                    RUN_TEST_INVOCATIONS=run_test_invocations_chunk)
    runtests_function_subchunks.append(runtests_function_chunk)
runtests_functions_chunk = '\n\n'.join(runtests_function_subchunks)

# Generate the value of the ADD_RUNTESTS_FUNCTIONS for the test_source_template, which
# consists of lines to go in main() to add all of the *_runtests() functions to the std::map
# runtests_funcs
add_runtests_functions_lines = ["  runtests_funcs.insert({"+f"std::string(\"{x}\"),{x}_runtests"+"});"
                                for x in sections]
add_runtests_functions_chunk = '\n\n'.join(add_runtests_functions_lines)


# Generate the source code and write it to file
file_text = test_source_template.substitute(RUNTESTS_FUNCTIONS=runtests_functions_chunk,
                                            ADD_RUNTESTS_FUNCTIONS=add_runtests_functions_chunk)
fh = open(TEST_SOURCE,'w')
fh.write(file_text)
fh.close()
